# ドキュメント管理システム 基本設計書

## 1. システム概要

### 1.1 システム目的

組織変遷と人員異動を考慮した統合的なドキュメントフォルダパス管理システムの構築により、効率的な文書管理と検索を実現する。

### 1.2 システム境界

- **対象**: ネットワークドライブ上の文書フォルダパス管理
- **除外**: 文書ファイル自体の内容管理・バージョン管理
- **連携**: Windows Active Directory、ファイルサーバー、Teams/Exchange

### 1.3 システム方式

- **アーキテクチャ**: 3層アーキテクチャ（プレゼンテーション・ビジネス・データ層）
- **実装方式**: 集中サーバー + 分散クライアント構成
- **API方式**: GraphQL単一API（効率的データ取得・型安全・REST不要）
- **認証方式**: Windows統合認証（Active Directory連携）
- **データ方式**: SQLite (WAL モード) + ネットワークドライブ
- **クライアント**:
  - **メイン**: Tauriアプリ（全機能 + OS統合）
  - **サブ**: Webブラウザ（閲覧・確認・軽作業）

## 2. アーキテクチャ設計

### 2.1 システム構成図

```text
[クライアント構成]
┌─────────────────────────────────────────┐    ┌─────────────────────┐
│     Tauriデスクトップアプリ              │    │   Webブラウザ       │
│  ┌─────────────┐  ┌──────────────────┐   │    │   (閲覧・確認)      │
│  │ Web UI機能  │  │ ネイティブ統合   │   │    │   基本機能のみ      │
│  │(Web+α機能) │  │ フォルダ操作     │   │    │                     │
│  │             │  │ OS通知・統合     │   │    │                     │
│  └─────────────┘  └──────────────────┘   │    │                     │
└─────────────────────────────────────────┘    └─────────────────────┘
              ↓ HTTPS + Tauri API                     ↓ HTTPS
              └─────────────┬─────────────────────────┘
                           ↓
        [統合Webサーバー（Axum + GraphQL）]
                ↓                    ↓
        [データベース（SQLite WAL）]  [ネットワークドライブ]
                ↓                    ↓
        [Active Directory]       [ファイル存在確認]
                ↓
        [通知システム（Teams/Email）]
```

### 2.2 技術アーキテクチャ

| レイヤー              | 技術要素                         | 選定理由                           |
| --------------------- | -------------------------------- | ---------------------------------- |
| **フロントエンド**    | SvelteKit + TypeScript           | コンポーネント指向・型安全・軽量   |
| **スタイリング**      | Tailwind CSS                     | ユーティリティファースト・高速開発 |
| **Tauriクライアント** | SvelteKit + Tauri                | Webクライアント + OS統合機能       |
| **Webクライアント**   | SvelteKit (静的配信)             | ブラウザ互換・軽量・アクセス容易   |
| **Webサーバー**       | **Axum** (Rust)                  | 軽量・柔軟・マルチDB対応           |
| **API**               | GraphQL                          | 効率的データ取得・型安全・柔軟性   |
| **データアクセス**    | **SQLx** + マイグレーション      | マルチDB対応・型安全・移行容易     |
| **データストア**      | SQLite → **SQL Server** (移行可) | 開発：軽量、本格運用：高性能       |

### 2.3 主要コンポーネント

#### 2.3.1 Tauriアプリケーション機能コンポーネント

- **Web+α機能クライアント**:
  - SvelteKit共通UI + TypeScript型安全
  - GraphQL API経由でのデータアクセス（Webと同様）
  - 追加のネイティブ統合機能のみ
  
- **ネイティブ統合機能（+α部分）**:
  - フォルダ直接オープン（エクスプローラー起動）
  - ファイルドラッグ&ドロップ・ファイル選択ダイアログ
  - システムトレイ・OS通知・キーボードショートカット
  - ウィンドウ管理・メニューバー

#### 2.3.2 Webクライアント機能コンポーネント

- **閲覧・確認機能**:
  - 文書検索・閲覧（基本機能）
  - 簡易登録・編集
  - レポート・統計表示
  - SvelteKit静的配信 + Tailwind CSS
  
- **アクセシビリティ**:
  - ブラウザからの軽量アクセス
  - 外出先・他端末からの確認
  - 管理者による緊急アクセス

#### 2.3.3 統合サーバー機能コンポーネント（DB・ロジック集中）

- **GraphQL APIサーバー**: 統一API・型安全・効率的データ取得
- **文書管理サービス**: 文書の登録・更新・検索
- **番号生成サービス**: ルールベース文書番号生成  
- **パス管理サービス**: ネットワークパス生成・管理
- **組織管理サービス**: 部署・人員・異動履歴管理
- **業務管理サービス**: 業務・従事者管理

#### 2.3.4 基盤機能コンポーネント

- **認証・認可サービス**: AD連携認証・権限制御
- **通知サービス**: Teams/Email通知
- **バッチサービス**: ファイル存在確認・AD同期
- **ログ・監査サービス**: 操作ログ・エラーログ管理

## 3. 機能アーキテクチャ

### 3.1 機能ブロック図

```text
[Tauriデスクトップアプリ - Web+α]
├── 共通Web UI（SvelteKit + TypeScript + Tailwind）
│   ├── 文書検索・閲覧・登録・編集・管理
│   ├── 業務・回覧管理  
│   ├── 設定・管理機能（ルール・権限・通知）
│   └── ダッシュボード・レポート・統計
│
├── ネイティブ統合機能（+α部分）
│   ├── フォルダ直接オープン・エクスプローラー起動
│   ├── ファイル操作（D&D・ファイル選択ダイアログ）
│   ├── システムトレイ・OS通知・ショートカット
│   └── ウィンドウ管理・メニューバー
│
└── サーバー連携
    └── GraphQL API経由（Webクライアントと同様）

[Webブラウザクライアント - 基本機能]
├── 共通Web UI（SvelteKit + TypeScript + Tailwind）
│   ├── 文書検索・閲覧
│   ├── 簡易登録・編集
│   └── レポート表示
│
└── 軽量アクセス
    ├── 外出先・他端末からの確認
    ├── 緊急時アクセス
    └── ゲストユーザー向け

[統合Webサーバー - 全機能・データ集中]
├── GraphQL APIサーバー（Actix-web）
├── 全ビジネスロジック
│   ├── 文書管理機能群（番号生成・パス管理・版管理・存在確認）
│   ├── 組織・人員管理機能群（構造管理・異動履歴・AD連携）
│   ├── 検索・回覧機能群（多条件検索・機密制御・回覧管理）
│   └── データ管理機能群（CSV取込み・バッチ処理・通知）
├── データベース（SQLite WAL モード）
├── ネットワークドライブアクセス
├── Active Directory連携
└── 外部システム連携（Teams/Email）
```

### 3.2 データフロー設計

#### 3.2.1 文書登録フロー

```text
1. [ユーザー入力] → 文書作成日・種別・部署・課
2. [番号生成サービス] → 適用ルール選択 → 文書番号生成
3. [パス管理サービス] → パスルール適用 → ネットワークパス生成
4. [文書管理サービス] → データベース保存
5. [通知サービス] → 関係者通知（必要時）
```

#### 3.2.2 検索フロー

```text
1. [ユーザー検索] → 検索条件入力
2. [認証・認可サービス] → 権限チェック・機密レベル確認
3. [文書管理サービス] → 条件検索・履歴検索
4. [組織管理サービス] → 過去所属部署考慮
5. [結果表示] → パス表示制御・機密マスク
```

### 3.3 軽量クライアント設計

#### 3.3.1 クライアント構成比較

| 項目               | Tauriアプリ        | Webブラウザ      |
| ------------------ | ------------------ | ---------------- |
| **基本構成**       | Web UI + OS統合    | Web UI のみ      |
| **データアクセス** | HTTP API（同じ）   | HTTP API（同じ） |
| **追加機能**       | ◎ ネイティブ統合   | ❌ なし           |
| **パフォーマンス** | ○ 同等レスポンス   | ○ 同等レスポンス |
| **アクセス性**     | △ インストール必要 | ◎ ブラウザのみ   |

#### 3.3.2 利用シーン分析

```text
[日常業務] → Tauriアプリ
├── 文書検索・登録（Web機能）
├── フォルダ直接オープン（+α機能）
├── ファイル操作・D&D（+α機能） 
└── システムトレイ常駐（+α機能）

[補助・確認] → Webブラウザ
├── 外出先・他端末からの確認
├── ゲストユーザーの閲覧
├── 緊急時の軽作業
└── インストール不可環境
```

#### 3.3.3 軽量設計のメリット

```rust
// Tauriアプリ：Web機能 + α機能のみ
#[tauri::command]
async fn open_network_folder(path: String) -> Result<(), String> {
    std::process::Command::new("explorer")
        .arg(path)
        .spawn()
        .map_err(|e| e.to_string())?;
    Ok(())
}

// メイン機能は全てWebサーバーのGraphQL API
async fn search_documents(query: SearchRequest) -> Result<Vec<Document>, Error> {
    let graphql_query = r#"
        query SearchDocuments($query: SearchInput!) {
            documents(search: $query) {
                id, title, number, path, createdAt
            }
        }"#;
    
    let response = reqwest::post(&format!("{}/graphql", SERVER_URL))
        .json(&serde_json::json!({
            "query": graphql_query,
            "variables": { "query": query }
        }))
        .await?
        .json::<GraphQLResponse<Vec<Document>>>()
        .await?;
    Ok(response.data)
}
```

### 3.4 外部システム連携

#### 3.4.1 Active Directory連携

- **同期方式**: 週次バッチ同期
- **連携データ**: 社員番号・氏名・メールアドレス・ADユーザー名
- **削除対応**: 論理削除（is_activeフラグ）
- **履歴保持**: 組織変更・人員異動履歴

#### 3.4.2 ファイルサーバー連携

- **アクセス方式**: UNCパス直接アクセス
- **権限制御**: ファイルサーバー側権限に依存
- **存在確認**: 月次バッチでパス・ファイル確認
- **エラー処理**: 不存在時の通知・ログ記録

#### 3.4.3 通知システム連携

- **Teams通知**: Webhook API経由
- **Email通知**: SMTP経由
- **通知タイミング**: 即時・定時・バッチ後
- **対象者決定**: 作成者・管理者・回覧先の自動判定

## 3.5 技術リスク・フォールバック戦略

### 3.5.1 Active Directory連携のフォールバック戦略

#### 段階的実装アプローチ

- **Phase 1: JSON手動投入（MVP）**

```rust
// 最初はシンプルにJSONファイルから読み込み
#[derive(serde::Deserialize)]
struct UserData {
    employee_id: String,
    name: String,
    email: String,
    department_code: String,
    section_code: String,
    is_active: bool,
}

// users.json から一括読み込み
async fn load_users_from_json() -> Result<Vec<UserData>, Error> {
    let json_data = tokio::fs::read_to_string("data/users.json").await?;
    let users: Vec<UserData> = serde_json::from_str(&json_data)?;
    Ok(users)
}
```

- **Phase 2: AD連携実装（将来）**

- Windows統合認証の実装
- LDAP同期バッチの実装
- フォールバック機能としてJSON読み込み保持

#### 認証方式の段階的実装

| Phase        | 認証方式                | 実装コスト | 運用コスト | 備考                   |
| ------------ | ----------------------- | ---------- | ---------- | ---------------------- |
| **Phase 1**  | JSON + 手動ユーザー選択 | 低         | 中         | 開発開始時・動作検証用 |
| **Phase 2**  | Windows統合認証         | 高         | 低         | 本格運用・自動認証     |
| **Fallback** | JSON読み込み継続        | -          | 低         | AD障害時の緊急運用     |

#### ADスキーマ依存の最小化

```rust
// ADスキーマに依存しない設計
#[derive(sqlx::FromRow)]
struct Employee {
    id: i64,
    employee_id: String,          // 社員番号（JSON/AD問わず）
    name: String,                 // 氏名
    email: Option<String>,        // メール（ADから取得可能なら）
    department_code: String,      // 部署コード（マッピングテーブル管理）
    section_code: String,         // 課コード（マッピングテーブル管理）
    ad_username: Option<String>,  // ADユーザー名（あれば）
    data_source: String,          // "json" | "ad_sync"
    is_active: bool,
    created_at: chrono::DateTime<chrono::Utc>,
    updated_at: chrono::DateTime<chrono::Utc>,
}
```

### 3.5.2 SQLite → SQL Server移行のフォールバック戦略

#### データ互換性確保

**Seed/JSONダンプ方式**:

```rust
// データベース間移行のためのシリアライズ
#[derive(serde::Serialize, serde::Deserialize)]
struct DatabaseDump {
    employees: Vec<Employee>,
    documents: Vec<Document>,
    departments: Vec<Department>,
    // ... 全テーブルデータ
}

// SQLiteからJSONダンプ
async fn dump_to_json(pool: &sqlx::Pool<sqlx::Sqlite>) -> Result<DatabaseDump, Error> {
    let employees = sqlx::query_as!(Employee, "SELECT * FROM employees")
        .fetch_all(pool).await?;
    // ... 他テーブルも同様
    
    Ok(DatabaseDump { employees, /* ... */ })
}

// SQL ServerにJSONロード
async fn load_from_json(pool: &sqlx::Pool<sqlx::Mssql>, dump: DatabaseDump) -> Result<(), Error> {
    // トランザクション内で一括挿入
    // ... 実装
}
```

#### クロスDB対応の設計

```rust
// 抽象化によるDB切り替え対応
pub trait DatabaseRepository {
    async fn get_documents(&self, query: &SearchQuery) -> Result<Vec<Document>, Error>;
    async fn create_document(&self, doc: &CreateDocumentRequest) -> Result<Document, Error>;
}

// 設定で切り替え
async fn create_repository() -> Box<dyn DatabaseRepository> {
    match std::env::var("DATABASE_TYPE").as_deref() {
        Ok("mssql") => Box::new(MssqlRepository::new().await),
        _ => Box::new(SqliteRepository::new().await),
    }
}
```

### 3.5.3 段階的リリース戦略

```text
Release 1 (Week 8):  基本機能 + JSON認証
├── 文書管理（登録・編集・基本検索）
├── JSON手動ユーザー管理
├── SQLite WAL モード
└── Tauriアプリ（基本機能）

Release 2 (Week 12): AD連携 + Web対応
├── Windows統合認証実装
├── AD同期バッチ（週次）
├── Webブラウザ対応
└── 高度検索機能

Release 3 (Week 16): 完全版
├── 全機能実装完了
├── 回覧管理機能
├── SQL Server移行対応
└── 運用最適化
```

### 3.5.4 緊急時対応

**データバックアップ**:

- SQLiteファイルの日次バックアップ
- JSONダンプの定期作成
- 設定ファイルのバージョン管理

**システム障害時**:

- AD障害 → JSON認証フォールバック
- DB障害 → バックアップからの復旧
- ネットワーク障害 → ローカルキャッシュ表示

## 4. 非機能設計

### 4.1 性能設計

| 項目             | 目標値                   | 設計方針                       |
| ---------------- | ------------------------ | ------------------------------ |
| **応答時間**     | 検索2秒以内              | インデックス最適化・キャッシュ |
| **同時接続数**   | 最大10ユーザー           | 非同期処理・コネクションプール |
| **データ容量**   | 100万件対応              | ページング・分割処理           |
| **スループット** | 1万件/時間（バッチ処理） | 並列処理・バルク操作           |

### 4.2 可用性設計

| 項目           | 目標値             | 設計方針               |
| -------------- | ------------------ | ---------------------- |
| **稼働時間**   | 平日8-18時 99%稼働 | 監視・自動復旧         |
| **復旧時間**   | 4時間以内          | バックアップ・復旧手順 |
| **データ保全** | 日次バックアップ   | 自動バックアップ・検証 |

### 4.3 セキュリティ設計

| 項目           | 対策                   | 実装方針               |
| -------------- | ---------------------- | ---------------------- |
| **認証**       | AD統合認証             | Windows認証・JWT       |
| **認可**       | 役割ベースアクセス制御 | 機密レベル・部署権限   |
| **通信暗号化** | HTTPS通信              | TLS1.3以上             |
| **監査ログ**   | 全操作ログ記録         | 構造化ログ・改ざん防止 |

## 5. 運用設計

### 5.1 デプロイメント設計

- **環境**: Windows Server 2019以上
- **配置**: スタンドアロン構成
- **データベース**: ローカルSQLiteファイル
- **ログ**: ローカルファイル + Windows EventLog

### 5.2 監視設計

- **システム監視**: プロセス・メモリ・ディスク容量
- **アプリケーション監視**: レスポンス時間・エラー率
- **ビジネス監視**: ファイル存在確認結果・通知配信状況

### 5.3 保守設計

- **バックアップ**: データベース日次バックアップ
- **ログローテーション**: 月次ローテーション・3ヶ月保持
- **設定変更**: 設定ファイル経由・再起動不要（一部）

## 6. 制約・前提条件

### 6.1 技術制約

- **OS**: Windows Server 2019以上
- **ネットワーク**: 既存ファイルサーバー・AD環境
- **ブラウザ**: Edge・Chrome（最新版）
- **同時接続**: 最大10ユーザー

### 6.2 運用制約

- **メンテナンス**: 平日19-22時のみ
- **データ移行**: 1ヶ月以内完了
- **ユーザー研修**: 最小限（直感的UI重視）

### 6.3 データ制約

- **既存データ**: 表記ゆれ・重複の名寄せ処理必要
- **履歴データ**: 部分的欠損あり・段階的補完
- **命名規則**: 複数世代混在・柔軟対応必要

## 7. 開発・配布方針

### 7.1 ハイブリッド開発アプローチ

#### 開発方針: Webサーバー + Tauriアプリ + Webクライアント

- **期間**: 16週間
- **成果物**:
  - **メイン**: Tauriアプリ（全機能 + OS統合）
  - **サブ**: Webクライアント（基本機能・ブラウザアクセス）
  - **共通**: Webサーバー（共有API・データ管理）
- **利点**:
  - フロントエンドコード共有（HTML/CSS/JS）
  - 柔軟なアクセス方法
  - ユーザーの使い分け可能

### 7.2 技術選定根拠

#### 7.2.1 技術スタック選定（SQL Server移行対応）

| 技術領域           | 選定技術                         | 選定理由                                     |
| ------------------ | -------------------------------- | -------------------------------------------- |
| **フロントエンド** | SvelteKit + TypeScript           | 軽量・高速・型安全・学習コスト低             |
| **スタイリング**   | Tailwind CSS                     | ユーティリティファースト・高速開発・一貫性   |
| **デスクトップ**   | Tauri                            | 軽量・セキュア・Webコード共有可能            |
| **バックエンド**   | **Axum** (Rust)                  | 軽量・柔軟・マルチDB対応・エコシステム豊富   |
| **ORM/クエリ**     | **SQLx** + マイグレーション      | マルチDB対応・型安全・SQL Server移行容易     |
| **API**            | GraphQL                          | 効率的データ取得・型安全・単一エンドポイント |
| **データベース**   | SQLite → **SQL Server** (移行可) | 開発：SQLite、本格運用：SQL Server移行対応   |

#### 7.2.2 SQL Server移行対応技術選定比較

| 比較項目           | **Axum + SQLx** (推奨)         | Actix-web + Diesel            |
| ------------------ | ------------------------------ | ----------------------------- |
| **マルチDB対応**   | ◎ SQLite/PostgreSQL/SQL Server | △ SQLite/PostgreSQL (限定)    |
| **SQL Server対応** | ◎ ネイティブサポート           | ❌ 公式サポートなし            |
| **型安全性**       | ◎ コンパイル時SQLチェック      | ◎ コンパイル時型チェック      |
| **移行容易性**     | ◎ 設定変更のみで移行可能       | ❌ ORM変更・コード書き直し必要 |
| **パフォーマンス** | ○ 十分な性能                   | ◎ 高性能                      |
| **エコシステム**   | ○ 成長中・Tokio連携良好        | ◎ 成熟・豊富なプラグイン      |
| **学習コスト**     | ○ 中程度                       | △ やや高い                    |
| **保守性**         | ◎ シンプル・移行時影響小       | △ 移行時大幅変更必要          |

#### 7.2.3 選定理由詳細

**SvelteKit + TypeScript**:

- コンパイル時型チェック・高い開発効率
- 小さなバンドルサイズ・高速ランタイム
- Tauriとの相性良好・コード共有可能

**Tailwind CSS**:

- CSS-in-JS不要・ビルド時最適化
- 一貫したデザインシステム・保守性向上
- SvelteKitとの統合容易

**Axum + SQLx + GraphQL**:

- REST API不要・単一エンドポイント
- マルチデータベース対応・将来の移行容易
- 型安全なクエリ・効率的データ取得
- SQL Server移行時のコード変更最小化

**SQLite → SQL Server移行パス**:

- 開発・小規模運用：SQLite WAL モード
- 本格運用・高負荷：SQL Server移行
- 設定変更のみで移行・コード変更不要
- 段階的スケーリング対応

#### 7.2.4 SQL Server移行戦略

**移行アプローチ**:

1. **Phase 1**: SQLite開発・小規模運用
   - 開発・テスト環境でのSQLite使用
   - 小規模運用（10ユーザー以下）での検証
   - SQLxによる抽象化レイヤーでDB依存コード最小化

2. **Phase 2**: SQL Server移行準備
   - 接続文字列・設定ファイルのみ変更
   - マイグレーションスクリプトのSQL Server対応
   - SQLxの機能でSQLite→SQL Server差分吸収

3. **Phase 3**: SQL Server本格運用
   - 高負荷・大規模データ対応
   - 高可用性・バックアップ・復旧機能活用
   - パフォーマンス最適化・クエリチューニング

**技術的メリット**:

```rust
// SQLxによるマルチDB対応例
#[derive(sqlx::FromRow)]
struct Document {
    id: i64,
    title: String,
    created_at: chrono::DateTime<chrono::Utc>,
}

// 同じコードでSQLite/SQL Server対応
async fn get_documents(pool: &sqlx::Pool<sqlx::Any>) -> Result<Vec<Document>, sqlx::Error> {
    sqlx::query_as!(Document, "SELECT id, title, created_at FROM documents")
        .fetch_all(pool)
        .await
}

// 設定でDBを切り替え
let database_url = std::env::var("DATABASE_URL")
    .unwrap_or_else(|_| "sqlite:./app.db".to_string());
// 本格運用時: "mssql://server/database" に変更のみ
```

**移行時の考慮事項**:

| 項目                   | SQLite                   | SQL Server               | 移行対応                 |
| ---------------------- | ------------------------ | ------------------------ | ------------------------ |
| **データ型**           | 動的型付け               | 厳密型付け               | SQLx型マッピング自動対応 |
| **制約・インデックス** | 基本的なもののみ         | 豊富な制約・最適化       | マイグレーション調整     |
| **トランザクション**   | WALモード対応            | 高度なトランザクション   | SQLx統一API対応          |
| **パフォーマンス**     | 小規模データ十分         | 大規模データ・高負荷対応 | クエリ最適化・調整       |
| **運用・監視**         | ファイルベース・シンプル | エンタープライズ機能     | 運用手順書更新           |

### 7.3 配布・運用設計

#### 7.3.1 Tauriアプリ配布

- **配布方法**: インストーラー配布（.msi/.exe形式）
- **インストール**: 管理者権限でサイレントインストール可能
- **更新**: Tauri内蔵自動更新機能（GitHub Releases等）
- **設定**: ローカル設定ファイル・レジストリ管理
- **軽量性**: 従来Electronより50%以上軽量

#### 7.3.2 Webクライアント配布

- **配布方法**: Webサーバー上でホスティング
- **アクセス**: イントラネット経由ブラウザアクセス
- **更新**: サーバー側更新で自動反映
- **設定**: ブラウザローカルストレージ・セッション管理

---

**最終更新**: 2024年12月
**作成者**: 開発チーム
**承認者**: プロジェクトマネージャー
